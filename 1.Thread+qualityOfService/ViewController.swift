//
//  ViewController.swift
//  1.Thread+qualityOfService
//
//  Created by Roman Vakulenko on 14.10.2022.
//

import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

// вариант как перевести код в другой поток (создать экземпляр класса Thread), может управлять
        let thread2 = Thread {
            for _ in 0...100 {
                print("2nd+++++++++++++++++")
            }
        }
        thread2.qualityOfService = .background // самый минимальный приоритет, используется для фоновых задач.

        thread2.start() //нужно, чтобы запустить поток, если сразу после вызвать .cancel, то thread2 не запустится, потому нужен "промежуточный код" (или любой иной код):
//        sleep(1)
//        thread2.cancel()

// вариант как перевести код в другой поток (инкапсулировать сложную логику в отдельный класс, наследованный от класса Thread, override func main)
        let thread3 = Thread3()
        thread3.qualityOfService = .userInteractive// самый высокий приоритет когда результат нужен прямо сейчас
        thread3.start()
//        sleep(1)
//        thread3.cancel()
    }
}

//RunLoop - цикл обработки событий, который используются для планирования работы и координации входящих событий. Его цель — держать поток занятым, когда есть работа, и погрузить его в сон, когда её нет. На каждой итерации он проверяет, не появилось ли событие, которое следует выполнить. Если такого события нет, RunLoop встаёт на небольшую паузу, а затем проверяет источники событий повторно.
//По умолчанию RunLoop есть только в главном потоке, в остальных, созданных вами, он отсутствует. Значит, в потоках не работает асинхронный код, таймеры и, к примеру, уведомления Realm. При этом любой поток без петли событий завершится, как только выполнится его код. Но как поступить, если необходимо добавить в потоки таймеры или не дать им закрываться на протяжении длительного времени? Создать и запустить в потоках RunLoop.
//Чтобы RunLoop появился в НЕглавном потоке, который обеспечит работу асинхронного кода, таймеров, уведомлений realm, то нужно в override func main написать КОД, кот. хочешь, чтобы выполнился параллельно и создать и запустить ранлуп: RunLoop.current.run ПОСЛЕ КОД
class Thread3: Thread {
    override func main() {
//        Самый простой пример асинхронной задачи — таймер. Блок таймера будет вызываться каждые 0.25 секунды, и на каждом витке это условие проверяет RunLoop, чтобы запустить код print("ok")
        Timer.scheduledTimer(withTimeInterval: 0.25, repeats: true) { _ in
            print("ok")
        } //
        RunLoop.current.run(until: Date() + 3) //запускаем RunLoop.current.run ПОСЛЕ кода, кот должен выполниться в текущем потоке (в НЕглавном)
    }
}

/*Уровни приоритетов
1. UserInteractive — самый высокий приоритет, когда результат нужен прямо сейчас.
2. UserInitiated — пониженный приоритет, когда результат важен, но допустима небольшая задержка.
3. Utility — почти минимальный приоритет — для ситуаций, когда результат может подождать.
4. Background — минимальный приоритет, используется для фоновых задач.
5. Default — приоритет по умолчанию, выбирается между userInitiated и utlility.
*/
